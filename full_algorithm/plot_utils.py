import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

"""Visualising predictions of model vs an empirical trajectory (for the fetch environments)"""

EMPIRICAL_DEFAULT = {"marker":"o", "markersize": 3, "color": (0,0,0,1), "markerfacecolor": (0,0,0,0.3),
                     "markeredgecolor":(0,0,0,0.2), "linestyle":"-"}
EMPIRICAL_OBJ_DEFAULT = {"marker":"o", "markersize": 3, "color": ((166.0/255.0),(166.0/255.0),(166.0/255.0),1), "markerfacecolor": (0,0,0,0.3),
                     "markeredgecolor":(0,0,0,0.2), "linestyle":"-"}
MODEL_DEFAULT = {"marker": "s", "markersize":3, "color":(1,0,0,1), "markerfacecolor": (1,0,0,0.3),
                 "markeredgecolor":(0,0,0,0.2), "linestyle":"--"}
MODEL_OBJ_DEFAULT = {"marker":"s", "markersize":3, "color":(1, (166.0/255.0), (166.0/255.0)), "markerfacecolor":(1,0,0,0.3),
                     "markeredgecolor":(0,0,0,0.2), "linestyle":"--"}

def plot_traj_vs_model_pred(model, env, num_steps=20, actions=None, start_state=None, object=False,
                            empirical_options=None, model_options=None, empirical_obj_options=None,
                            model_obj_options=None):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    if empirical_options is None:
        empirical_options = EMPIRICAL_DEFAULT
    if empirical_obj_options is None:
        empirical_obj_options = EMPIRICAL_OBJ_DEFAULT
    if model_options is None:
        model_options = MODEL_DEFAULT
    if model_obj_options is None:
        model_obj_options = MODEL_OBJ_DEFAULT
    if start_state is not None:
        env.restore_state(start_state)
        obs = env._get_obs()
    else:
        obs = env.reset()
    state_traj_emp = np.zeros((num_steps+1, env.state_dim))
    state_traj_model = np.zeros((num_steps+1, env.state_dim))
    state_traj_emp[0, :] = obs["observation"]
    state_traj_model[0, :] = obs["observation"]
    for i in range(num_steps):
        if actions is None:
            a = actions[i, :]
        else:
            a = env.action_space.sample()
        obs, _, _, _ = env.step(a)
        pred_obs = model.predict(state_traj_model[i, :], a)
        state_traj_emp[i+1, :] = obs["observation"]
        state_traj_model[i+1, :] = pred_obs
    robot_emp = env.get_robot_pos_from_state(state_traj_emp)
    ax.plot(robot_emp[:, 0], robot_emp[:, 1], robot_emp[:, 2], **empirical_options)
    robot_model = env.get_robot_pos_from_state(state_traj_model)
    ax.plot(robot_model[:, 0], robot_model[:, 1], robot_model[:, 2], **model_options)
    if object:
        obj_emp = env.get_obj_pos_from_state(state_traj_emp)
        ax.plot(obj_emp[:, 0], obj_emp[:, 1], obj_emp[:, 2], **empirical_obj_options)
        obj_model = env.get_obj_pos_from_state(state_traj_model)
        ax.plot(obj_model[:, 0], obj_model[:, 1], obj_model[:, 2], **model_obj_options)
        all_data = np.concatenate((robot_emp, robot_model, obj_model, obj_emp), axis=0)
    else:
        all_data = np.concatenate((robot_model, robot_emp), axis=0)
    X = all_data[:, 0]
    Y = all_data[:, 1]
    Z = all_data[:, 2]
    max_range = np.array([X.max() - X.min(), Y.max() - Y.min(), Z.max() - Z.min()]).max() / 2.0
    mid_x = (X.max() + X.min()) * 0.5
    mid_y = (Y.max() + Y.min()) * 0.5
    mid_z = (Z.max() + Z.min()) * 0.5
    ax.set_xlim(mid_x - max_range, mid_x + max_range)
    ax.set_ylim(mid_y - max_range, mid_y + max_range)
    ax.set_zlim(mid_z - max_range, mid_z + max_range)

"""Plot clouds of points generated by the GAN forwards in time (towards the goal)
WILL NEED TO MODIFY THIS FOR OBJECT ENV
"""
OPACITY = 0.1
COLOURS_DEFAULT = [[1,0,0,OPACITY], [0,0,1,OPACITY], [0,1,0,OPACITY], [0,0,0,OPACITY]]
"""
Should include subplot option - show progression. Maybe also animation would be good.
"""
def plot_goal_clouds(G, start_state, end_goal, num_steps=5, num_points_per_cloud=500, colours=None,
                     steps_to_plot="all"):
    if colours is None:
        colours = COLOURS_DEFAULT
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(start_state[0], start_state[1], start_state[2], s=60, c="red")
    ax.scatter(end_goal[0], end_goal[1], end_goal[2], s=60, c="black")
    curr_states = np.tile(start_state, (num_points_per_cloud, 1))
    end_goal = np.tile(end_goal, (num_points_per_cloud, 1))

    for i in range(num_steps):
        gen_states = G.generate(curr_states, end_goal)
        if steps_to_plot == "all" or i in steps_to_plot:
            ax.scatter(gen_states[:, 0], gen_states[:, 1], gen_states[:, 2], c=colours[i%len(colours)])
        curr_states = gen_states


"""TEST"""
robot_emp = np.zeros((20, 3))
obj_emp = np.zeros((20, 3))
obj_emp[0,:] = np.array([1.0, 1.0, 1.0])
for i in range(1, 20):
    robot_emp[i, :] = robot_emp[i-1, :] + 0.2*np.random.randn(3)
    obj_emp[i, :] = obj_emp[i-1, :] + 0.2*np.random.randn(3)

robot_model = robot_emp + 0.1*np.random.randn(20, 3)
obj_model = obj_emp + 0.1*np.random.randn(20,3)

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

ax.plot(robot_emp[:, 0], robot_emp[:, 1], robot_emp[:, 2], **EMPIRICAL_DEFAULT)
ax.plot(robot_model[:, 0], robot_model[:, 1], robot_model[:, 2], **MODEL_DEFAULT)
ax.plot(obj_emp[:, 0], obj_emp[:, 1], obj_emp[:, 2], **EMPIRICAL_OBJ_DEFAULT)
ax.plot(obj_model[:, 0], obj_model[:, 1], obj_model[:, 2], **MODEL_OBJ_DEFAULT)
all_data = np.concatenate((robot_emp, robot_model, obj_model, obj_emp), axis=0)
X = all_data[:, 0]
Y = all_data[:, 1]
Z = all_data[:, 2]
max_range = np.array([X.max() - X.min(), Y.max() - Y.min(), Z.max() - Z.min()]).max() / 2.0
mid_x = (X.max() + X.min()) * 0.5
mid_y = (Y.max() + Y.min()) * 0.5
mid_z = (Z.max() + Z.min()) * 0.5
ax.set_xlim(mid_x - max_range, mid_x + max_range)
ax.set_ylim(mid_y - max_range, mid_y + max_range)
ax.set_zlim(mid_z - max_range, mid_z + max_range)

print("OK")